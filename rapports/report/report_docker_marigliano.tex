% inspired from: https://github.com/SnipyJulmy/hesso-latextemplate-lab
\documentclass[11pt,a4paper,oneside]{report}
\usepackage[margin=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{minted}
\usepackage{titlesec}
\usepackage[pdftex]{graphicx} % graphics importing
\usepackage{titling} % can use \theauthor \thetitle
\usepackage{parskip} % remove first line indenting in a section
\usepackage{microtype} % typographic improvements
\usepackage[defaultlines=3,all]{nowidow}
\usepackage[toc,page]{appendix}
\usepackage{verbatim}
\usepackage{float}
\usepackage{enumerate}
\usepackage{lmodern}
\usepackage{pdflscape}
\usepackage{subfig}

% == Header and Footer
\usepackage{fancyhdr}

% style for all normal pages
\fancypagestyle{normal}{
\fancyhf{}
\setlength\headheight{14pt}
\lhead[]{Docker and Embedded systems}
\chead[]{}
\rhead{\includegraphics[width=3cm]{img/mse_logo}}
\lfoot[]{\nouppercase{\leftmark}}
\cfoot[]{}
\rfoot[]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}% Default \headrulewidth is 0.4pt
\renewcommand{\footrulewidth}{0.4pt}% default is 0pt
}

% style for history
\fancypagestyle{historystyle}{
\setlength\headheight{14pt}
\lhead[]{Docker and Embedded systems}
\chead[]{}
\rhead{\includegraphics[width=3cm]{img/mse_logo}}
\lfoot[]{}
\cfoot[]{}
\rfoot[]{}

\renewcommand{\headrulewidth}{0.4pt}% Default \headrulewidth is 0.4pt
\renewcommand{\footrulewidth}{0pt}
}

\usepackage[hyphens]{url} % line wrap urls
\usepackage{hyperref}

% == Version history
\usepackage{vhistory}


% == Code snippets
\newminted{bash}{xleftmargin=20pt, linenos=true, breaklines=true, frame=single, framesep=6pt, tabsize=2, fontfamily=courier, fontsize=\small}

% inline code
\newcommand{\code}[1]{\texttt{#1}}

% == Chapter titles
% Remove space before title
\titlespacing{\chapter}{0pt}{*-4}{*3}
% Remove "Chapter N" and use a sans-serif font
\titleformat{\chapter}{\normalfont\huge}{\thechapter.}{20pt}{\huge}
% Change chapter page style
\patchcmd{\chapter}{plain}{fancy}{}{}



% Metadata
\newcommand{\school}{Haute École d'ingénierie et d'architecture de Fribourg}
\newcommand{\oldreportname}{État de l’art à la mi-projet de semestre Docker and embedded systems - Ou comment ne pas cross compiler Docker sur ARM}

\title{Projet de semestre Docker and embedded systems}
\author{Gary \bsc{Marigliano}}
\newcommand{\version}{0.0.3}

% aliases
\newcommand{\odroid}{ODROID-XU3 Lite }

\begin{document}

\begin{titlepage}
\begin{center}

\includegraphics[width=0.6\textwidth]{img/docker_logo}\\[1cm]

\begin{figure}[htbp]
\begin{minipage}[c]{.45\linewidth}
\begin{flushleft}
\includegraphics[width=7cm]{img/mse_logo}
\end{flushleft}
\end{minipage}
\hfill
\begin{minipage}[c]{.45\linewidth}
\begin{flushright}
\includegraphics[height=2cm]{img/logo_hes-so}
\end{flushright}
\end{minipage}
\end{figure}

% Title
\rule{\linewidth}{0.5mm} \\[0.4cm]
{ \huge \bfseries \thetitle \\[0.4cm] }
\rule{\linewidth}{0.5mm} \\[1.5cm]

% Author and supervisor
\noindent
\begin{minipage}{0.4\textwidth}
  \begin{flushleft} \large
    \emph{Auteur :}\\
    \theauthor
  \end{flushleft}
\end{minipage}%
\begin{minipage}{0.4\textwidth}
  \begin{flushright} \large
    \emph{Encadrant :} \\
    Jean-Roland \bsc{Schüler}
  \end{flushright}
\end{minipage}

\vfill

\noindent
\begin{minipage}{0.4\textwidth}
  \begin{flushleft} \large
    \emph{Contact :}\\
    gary.marigliano@master.hes-so.ch
  \end{flushleft}
\end{minipage}%
\begin{minipage}{0.4\textwidth}
  \begin{flushright} \large
    \emph{Mandant :} \\
    \school
  \end{flushright}
\end{minipage}

\vfill

% Bottom of the page
{\large Version \version \\ \today}


\end{center}
\end{titlepage}

\pagestyle{historystyle}
\begin{versionhistory}  
  \vhEntry{0.0.1}{02.05.16}{\theauthor}{Création du document}
  \vhEntry{0.0.2}{05.05.16}{\theauthor}{Ajout des chapitres Matériel utilisé, Présentation de Docker}
    \vhEntry{0.0.3}{11.05.16}{\theauthor}{Rédaction des sections Situation actuelle, Séparation des données Docker dans une partition chiffrée, Planning }
\end{versionhistory}


\chapter{Résumé du document}

TODO

\pagenumbering{gobble}
\tableofcontents
\pagenumbering{arabic}

\pagestyle{normal}

\chapter{Introduction}

\section{Contexte}\label{contexte}

Ce document est le rapport de fin de projet de semestre Docker and embedded systems. Un des buts de ce projet est de cross compiler Docker à partir de ses sources pour produire un binaire exécutable sur un \odroid (ARMv7). De plus, une partie concernant la sécurité de Docker est également traitée.

Lien: \url{https://github.com/krypty/docker_and_embedded_systems}

Ce projet de semestre s'inscrit dans une certaine continuité avec les projets de semestre et de bachelor de M. Loic Bassang \cite{bassang_bachelor}. Plusieurs pistes intéressantes avaient en effet été mentionnées dans ces projets là notamment une partie concernant la sécurité et Docker. Ainsi, ce rapport fera parfois des parallèles avec ces documents.

Il est important de noter que la vitesse de développement de Docker est assez hallucinante. En effet, sur Github (\url{https://github.com/docker/docker}) les commits se succèdent à vitesse grand V. Entre chaque version de Docker, qui sortent environ tous les mois, il est courant d'avoir plus de 3000 commits qui ont été \emph{pushés}. Tout ceci pour dire qu'à la lecture de ce document, il est quasiment sûr que certaines pistes explorées soient définitivement obsolètes ou au contraire deviennent la voie à suivre du à une mise à jour quelconque.


\section{Objectifs}

De manière plus précise, ce projet vise à maitriser les parties suivantes:

\begin{enumerate}
  \item Construction d'un système Linux capable de faire tourner Docker et son \emph{daemon} en utilisant Buildroot. Pour générer le dit système, on dispose d'un \emph{repository} Gitlab hébergé à la \school

  \item Cross compilation de Docker et de son \emph{daemon}, capable de faire tourner des containers
  
  \item Comprendre, analyser et évaluer l'aspect sécurité de Docker dans le cadre d'une utilisation avec une carte embarquée
\end{enumerate}

Les deux premiers points ont été traités dans un précédent rapport appelé "\oldreportname".

Ce document se concentre, dès lors, sur le dernier point ainsi que sur le déroulement global du projet.


\chapter{Présentation de Docker}

\textbf{Remarque : } Si le lecteur a déjà lu le rapport "\oldreportname", il ne lui est pas nécessaire de relire ce chapitre sachant qu'il s'agit du même contenu.

\input{../presentation-docker}

\chapter{Matériel utilisé et mise en place de la cible}

Ce chapitre présente le matériel utilisé dans le projet ainsi que son installation et sa configuration de base.

Afin de réaliser ce projet, une carte embarquée \odroid a été mise à disposition afin d'y faire tourner Docker. 

\section{La carte \odroid}

Cette carte possède les caractéristiques suivantes \cite{hardkernel_odroid_xu3}: 

\begin{itemize}
\item Samsung Exynos5422 Cortex™-A15 1.8Ghz quad core and Cortex™-A7 quad core CPUs 
\item Mali-T628 MP6(OpenGL ES 3.0/2.0/1.1 and OpenCL 1.1 Full profile)
\item 2Gbyte LPDDR3 RAM at 933MHz (14.9GB/s memory bandwidth) PoP stacked
\item eMMC5.0 HS400 Flash Storage
\item USB 3.0 Host x 1, USB 3.0 OTG x 1, USB 2.0 Host x 4
\item HDMI 1.4a for display
\end{itemize}

\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.5]{img/ODROIDXU3Lite.jpg}
\caption{\odroid}
\end{figure}

Lien vers le constructeur : \url{http://www.hardkernel.com/main/products/prdt_info.php?g_code=G141351880955}.

\section{Installation du système}

Initialement, il était prévu de générer un système d'exploitation minimal qui aurait été capable de faire tourner Docker et des containers. Malheureusement, il n'a pas été possible de cross compiler Docker \textit{et son daemon} afin de lancer des containers sur ce système minimal. Plus d'informations sont disponibles dans le rapport \oldreportname. 

Ainsi, il a été décidé, de la même manière que pour le travail de bachelor précédent, d'utiliser une distribution GNU/Linux proposant Docker dans ses packages. Le choix s'est donc porté sur \textbf{Archlinux ARM} \footnote{Arch Linux ARM : \url{https://archlinuxarm.org/}}.

Sur la page wiki de la distribution (\url{https://archlinuxarm.org/platforms/armv7/samsung/odroid-xu3}), on peut suivre un guide de génération de la carte SD qui contient le système d'exploitation. Une copie de ce guide est disponible à l'appendice \ref{install_alarm_odroid}.


\section{Installation de Docker}
Une fois le système installé et démarré, il convient d'installer Docker depuis les dépôts de la distribution.

Ceci peut être accompli avec les commandes suivantes :

\begin{bashcode}
pacman -Syyu
reboot
pacman -S docker
systemctl enable docker
systemctl start docker
docker version
\end{bashcode}

Sortie:

\begin{bashcode}
Client:
 Version:      1.10.3
 API version:  1.22
 Go version:   go1.6
 Git commit:   20f81dd
 Built:        Sat Mar 12 12:49:56 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.10.3
 API version:  1.22
 Go version:   go1.6
 Git commit:   20f81dd
 Built:        Sat Mar 12 12:49:56 2016
 OS/Arch:      linux/arm
 \end{bashcode}


\chapter{Objectif 3 - Docker et la sécurité}

\section{Situation actuelle}
Pour cette partie du projet, l'objectif est le suivant : Analyser et évaluer l'aspect sécurité de Docker dans le cadre d'une utilisation avec une carte embarquée.

Pour rappel, on utilise la carte \odroid. Un des objectifs de ce projet était de générer un système GNU/Linux minimal contenant un binaire Docker cross-compilé. Malheureusement, cet objectif n'a pas abouti comme expliqué dans le rapport "\oldreportname".

Pour continuer sur la partie sécurité, il a été choisi d'utiliser une distribution GNU/Linux compatible avec la carte et qui propose dans ces dépôts un package Docker précompilé. Tout comme le travail précédent de M. Loïc Bassang, Arch Linux ARM a été sélectionné.

\section{Structure de la suite du document}

Pour ce projet, il a été décidé d'étudier la question de la sécurité avec Docker avec une approche en couches. A peu à la manière du modèle OSI\footnote{Modèle OSI: \url{https://fr.wikipedia.org/wiki/Mod\%C3\%A8le_OSI}} en réseau, chaque couche représente un ensemble de fonctionnalités qui, dans le cas de ce projet, doit faire l'objet d'une évaluation de la sécurité.

L'étude de la sécurité de Docker a donc été séparée avec les couches \textit{arbitraires} suivantes:

\begin{itemize}

\item Compilation et installation de Docker : en particulier les options  de compilation

\item \nameref{config_systeme_os_hote} : configuration du kernel, configuration des options de lancement de Docker, etc.

\item \nameref{creation_utilisation_images_docker} : Bonnes pratiques et contraintes liées au monde de l'embarqué

\item \nameref{utilisation_containers} : options de lancement

\end{itemize}

\textbf{Remarque : } Chacune de ces couches fait l'objet d'un chapitre dans ce rapport excepté le premier point : Compilation et installation de Docker. En effet, celui-ci n'est pas traité car, comme annoncé précédemment, la cross compilation de Docker sur un système ARM n'a pas aboutie. L'effort est alors concentré sur les autres points.


\chapter{Configuration du système d'exploitation hôte}\label{config_systeme_os_hote}
TODO 
Dans ce chapitre, on présente diverses bonnes pratiques et configurations dans le but de sécuriser Docker et/ou le système l'hébergeant.

Parmi ces techniques, on peut citer :

\begin{itemize}
\item TODO
\item TODO
\end{itemize}


\section{Passage en revue du benchmark de sécurité : CIS Docker 1.11.0 Benchmark}
TODO décrire ce que c'est ce bench, énumerer les points testés et en explorer un certain nombre


\subsection{Ne pas utiliser AUFS}
TODO


\subsection{User namespace}
TODO


\subsection{Interdiction de la communication réseau entre containers}
TODO


\section{Séparation des données Docker dans une partition chiffrée}
Dans cette section, une partition chiffrée sera créée sur la cible afin d'isoler les données (images et containers principalement) de Docker du reste du système. La partition sera chiffrée afin d'accroître la sécurité des données.

Les étapes suivantes seront réalisées :
\begin{enumerate}
\item Redimensionnement de la partition principale
\item Création d'une partition chiffrée
\item Montage manuel de la partition chiffrée
\item Montage au boot de la partition chiffrée
\item Preuve de bon fonctionnement du montage automatique
\item Binding des données de Docker sur la partition chiffrée
\item Analyse de la solution proposée
\end{enumerate}

\subsection{Redimensionnement de la partition principale}
Actuellement, il n'y a qu'une partition sur la cible; la partition principale. Il faut réduire la partition principale et créer une partition dans le nouvel espace libre. Pour ce faire, l'outil GParted\footnote{GParted : \url{http://gparted.org/}} a été utilisé car il permet de voir visuellement ce qui est réalisé.



\begin{figure}[H]
    \subfloat[Situation initiale - Une seule partition]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gparted1.png}
    }
    \hfill
    \subfloat[Redimensionnement de la partition principale]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gparted2.png}
    }
        
    \subfloat[Création de la partition pour les données Docker]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gparted3.png}
    }
    \hfill
    \subfloat[Confirmation]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gparted4.png}
    }
    
     \subfloat[Partitionnement en cours...]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gparted5.png}
    }
    \hfill
    \subfloat[Situation finale - Deux partitions, la principale et celle pour Docker]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gparted6.png}
    }
    \caption{Redimensionnement de la partition principale}
\end{figure}

\subsection{Création d'une partition chiffrée}

Maintenant la carte SD correctement partitionnée, il faut créer la partition chiffrée avec LUKS. Pour ce faire, Gnome Disks Utility va être utilisé\footnote{Gnome Disk Utility : \url{https://doc.ubuntu-fr.org/gnome-disk-utility}}.

\begin{figure}[H]
    \subfloat[Sélection de la partition à chiffrer. Cliquer sur la roue crantée et sélectionner "Format Partition...".]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gnome-disks1.png}
    }
    \hfill
    \subfloat[Sélectionner "Encrypted, compatible with Linux systems (LUKS + ext4)" et saisir une passphrase (mot de passe)]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gnome-disks2.png}
    }
        
    \subfloat[La partition chiffrée est créée]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gnome-disks3.png}
    }
    \caption{Création de la partition chiffrée avec Gnome Disk Utility}
\end{figure}


\subsection{Montage manuel de la partition chiffrée}
Maintenant que la partition chiffrée a été créée, on peut replacer la carte SD dans la cible et la démarrer.

Pour monter manuellement la partition, il faut réaliser les commandes suivantes : 
\begin{bashcode}
sudo mkdir /mnt/docker-data
sudo cryptsetup luksOpen /dev/mmcblk0p2 docker-data
sudo mount /dev/mapper/docker-data /mnt/docker-data/
\end{bashcode}

\code{/dev/mmcblk0p2} représente la partition chiffrée de la carte SD.

\subsection{Montage au boot de la partition chiffrée}
Monter manuellement la partition n'est pas une solution possible si l'on souhaite y mettre les données de Docker dessus. En effet, pour que Docker stocke ces données (rappel: les images et les containers) dans la partition chiffrée, il faut monter cette partition au démarrage de la cible et créer un \textit{bind mount} sur \code{/var/lib/docker}. 


Avant d'effectuer le \textit{bind mount}, on va déjà faire en sorte de monter la partition chiffrée au boot.


Pour monter la partition chiffrée au démarrage du système, il faut ouvrir le fichier \code{/etc/crypttab} sur la cible, et ajouter la ligne suivante :
\begin{bashcode}
docker-data /dev/mmcblk0p2  none luks
\end{bashcode}

De manière similaire, il faut ajouter cette ligne dans le fichier \code{/etc/fstab} : 
\begin{bashcode}
/dev/mapper/docker-data /mnt/docker-data ext4 rw 0 0
\end{bashcode}


\subsection{Preuve de bon fonctionnement du montage automatique}
Pour vérifier que tout ceci fonctionne bien, il suffit de redémarrer la cible et on devrait observer les lignes suivantes au boot :

\begin{bashcode}
[  OK  ] Found device /dev/mmcblk0p2.
[    9.449751] [c5] INA231 3-0041: I2C write error: (-6) reg: 0x0
[    9.454336] [c5] INA231 3-0041: ============= Probe INA231 Fail! : sensor_mem (0xFFFFFFFA) =============
[    9.472839] [c5] INA231 3-0044: I2C write error: (-6) reg: 0x0
[    9.477448] [c5] INA231 3-0044: ============= Probe INA231 Fail! : sensor_g3d (0xFFFFFFFA) =============
[    9.495472] [c4] INA231 3-0045: I2C write error: (-6) reg: 0x0
[    9.500009] [c4] INA231 3-0045: ============= Probe INA231 Fail! : sensor_kfc (0xFFFFFFFA) =============
[    9.511555] [c4] s3c-i2c 12c60000.i2c: i2c-3: S3C I2C adapter
[    9.516095] [c4] s3c-i2c 12c70000.i2c: slave address 0x00
         Starting Cryptography Setup for docker-data...
[    9.529339] [c5] s3c-i2c 12c70000.i2c: i2c-4: S3C I2C adapter
[  OK  ] Reached target Sound Card.
[    9.782604] [c5] smsc95xx v1.0.4
[    9.838453] [c7] smsc95xx 1-1.1:1.0 eth0: register 'smsc95xx' at usb-12110000.usb-1.1, smsc95xx USB 2.0 Ethernet, 9
[    9.849106] [c7] usbcore: registered new interface driver smsc95xx
[    9.946259] [c6] usbcore: registered new interface driver rtl8192cu
Please enter passphrase for disk docker-data on /mnt/docker-data! ******
[***   ] (1 of 2) A start job is running for...for docker-data (13s / no limit)[   22.871246] [c5] NET: Registered pr8
[**    ] (1 of 2) A start job is running for...for docker-data (13s / no limit)[   23.925487] [c6] bio: create slab <1
[  OK  ] Found device /dev/mapper/docker-data.
[  OK  ] Started Cryptography Setup for docker-data.
[  OK  ] Reached target Encrypted Volumes.
         Mounting /mnt/docker-data...
[   24.117386] [c5] EXT4-fs (dm-0): mounted filesystem with ordered data mode. Opts: (null)
[  OK  ] Mounted /mnt/docker-data.
\end{bashcode}

Le système va se bloquer pour que la saisie de la passphrase soit effectuée :
\begin{bashcode}
Please enter passphrase for disk docker-data on /mnt/docker-data! ******
\end{bashcode}

Une fois connecté, il est tout à fait possible de d'écrire des données sur la partition chiffrée :
\begin{bashcode}
echo "LUKS je suis ton père !" > /mnt/docker-data/starwars.txt
\end{bashcode}


\subsection{Binding des données de Docker sur la partition chiffrée}
Maintenant, on veut faire en sorte que les données de Docker soient dans cette partition chiffrée. Pour ce faire, on va effectuer un \textit{bind mount} entre un dossier dans la partition chiffrée et le dossier de Docker.

Un bind mount n'est rien d'autre qu'un montage de dossier dans un autre dossier. On va donc monter \code{/mnt/docker-data/docker} dans \code{/var/lib/docker}. De cette manière, aucune configuration supplémentaire de Docker n'est nécessaire et ceci est donc complètement transparent pour lui. Cette opération est persistante après un redémarrage.

\textbf{Attention : } Les opérations suivantes impliquent la perte de toutes les images et containers précédemment créés.

Création du dossier \code{docker} sur la partition chiffrée, à faire sur la cible :
\begin{bashcode}
sudo systemctl stop docker # on stoppe le service Docker avant tout
cd /mnt/docker-data
mkdir -p var/lib/docker
sudo rm -rf /var/lib/docker/ # supprime toutes les données de Docker !!!
sudo mkdir /var/lib/docker
\end{bashcode}

Sur la cible, on fait ensuite un bind mount entre la partition chiffrée et le dossier Docker de base

\begin{bashcode}
sudo vim /etc/fstab

# dans ce fichier, on ajoute la ligne suivante
/mnt/docker-data/var/lib/docker /var/lib/docker none bind 0 0
\end{bashcode}

A la suite de ces modifications, le fichier /etc/fstab ressemble à ceci:
\begin{bashcode}
#
# /etc/fstab: static file system information
#
# <file system> <dir>   <type>  <options>       <dump>  <pass>
/dev/mapper/docker-data /mnt/docker-data ext4 rw 0 0
/mnt/docker-data/var/lib/docker /var/lib/docker none bind 0 0
\end{bashcode}


Désormais les données de Docker sont stockées sur une partition séparée et chiffrée. Pour prouver que c'est bien le cas, il suffit de relancer le benchmark de sécurité:

\begin{bashcode}
cd /home/alarm/docker/docker-bench-security
sudo bash docker-bench-security.sh

# la sortie indique:
[PASS] 1.1  - Create a separate partition for containers
\end{bashcode}


\subsection{Analyse de la solution proposée}
Stocker les données de Docker dans une partition chiffrée est une bonne initiative mais il faut garder à l'esprit les implications suivantes :
\begin{itemize}

\item La partition chiffrée est montée au boot. Ceci implique quand cas de reboot de la machine, il faut avoir un accès physique à celle-ci car le service ssh n'est pas encore lancé à ce moment là. En cas de dépannage à distance, il n'est pas donc possible de reboot la cible.
\item Les performances quand on utilise Docker devraient être diminuées dû au chiffrement
\item L'utilisation d'une partition séparée permet de réinstaller le système sans perdre les données liées à Docker et ses containers.
\item Le chiffrement des containers Docker apporte une plus value en terme de sécurité
\end{itemize}

\section{TODO}
TODO


\chapter{Création et utilisation des images Docker}\label{creation_utilisation_images_docker}
TODO : ce chapitre montre comment et pourquoi créer et utiliser des images Docker qui soient sécurisées et adaptées au monde de l'embarqué (taille principalement). Utilisation des hash cryptographiques pour l'OS utilisé et les versions des logiciels installés. 
Montrer un cas pratique avec une image commune basée sur alpine linux dire ce que ca apporte de travailler ainsi et pourquoi il faut le faire.


\chapter{Utilisation des containers}\label{utilisation_containers}
TODO : parler de la philosophie des containers légers et éphémères, comment les exécuter de manière sûre et sécurisée, comment limiter le pouvoir des containers (conso ram, ddos, communication avec le monde extérieur ou entre containers, ...)

\begin{landscape}
\chapter{Déroulement du projet}


\section{Planning initial}
\begin{figure}[ht]
\centering
\includegraphics[height=4.7cm]{img/initial_planning.png}
\caption{Planning initial - 04.03.2016}
\end{figure}


\section{Planning final}
\begin{figure}[ht]
\centering
\includegraphics[draft,height=4.7cm]{img/initial_planning.png}
\caption{Planning final - TODO date}
\end{figure}

\end{landscape}
\chapter{Proposition d'améliorations vis à vis du travail précédent}
TODO: Pas prioritaire, a voir si on a le temps ! passer en revue et critique positivement le travail de Bachelor précédent. Dire que ce n'est pas une critique négative mais apporter un avis supplémentaire et plus récent (Docker évoluant beaucoup)


\chapter{Conclusion}
TODO... ce qu'on voulait faire, ce qui a été fait, ce qu'il reste à faire/pourrait faire


% == Bibliography
\nocite{*} % cite all
\bibliographystyle{plain}
\bibliography{bibliography}

\begin{appendices}
\chapter{Installation de Archlinux ARM sur \odroid}\label{install_alarm_odroid}

\textbf{Remarque : }Ce guide requiert l'utilisation d'un ordinateur sous GNU/Linux.

Source : \url{https://archlinuxarm.org/platforms/armv7/samsung/odroid-xu3}

\input{appendices/archlinux_arm_odroid_xu3_install}

\end{appendices}

\end{document}
