% inspired from: https://github.com/SnipyJulmy/hesso-latextemplate-lab
\documentclass[11pt,a4paper,oneside]{report}
\usepackage[margin=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{minted}
\usepackage{titlesec}
\usepackage[pdftex]{graphicx} % graphics importing
\usepackage{titling} % can use \theauthor \thetitle
\usepackage{parskip} % remove first line indenting in a section
\usepackage{microtype} % typographic improvements
\usepackage[defaultlines=3,all]{nowidow}
\usepackage[toc,page]{appendix}
\usepackage{verbatim}
\usepackage{float}
\usepackage{enumerate}
\usepackage{lmodern}
\usepackage{pdflscape}
\usepackage{subfig}

% == Header and Footer
\usepackage{fancyhdr}

% style for all normal pages
\fancypagestyle{normal}{
\fancyhf{}
\setlength\headheight{14pt}
\lhead[]{Docker and Embedded systems}
\chead[]{}
\rhead{\includegraphics[width=4cm]{img/mse_logo}}
\lfoot[]{\nouppercase{\leftmark}}
\cfoot[]{}
\rfoot[]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}% Default \headrulewidth is 0.4pt
\renewcommand{\footrulewidth}{0.4pt}% default is 0pt
}

% style for history
\fancypagestyle{historystyle}{
\setlength\headheight{14pt}
\lhead[]{Docker and Embedded systems}
\chead[]{}
\rhead{\includegraphics[width=4cm]{img/mse_logo}}
\lfoot[]{}
\cfoot[]{}
\rfoot[]{}

\renewcommand{\headrulewidth}{0.4pt}% Default \headrulewidth is 0.4pt
\renewcommand{\footrulewidth}{0pt}
}

\usepackage[hyphens]{url} % line wrap urls
\usepackage{hyperref}

% == Version history
\usepackage{vhistory}


% == Code snippets
\newminted{bash}{xleftmargin=20pt, linenos=true, breaklines=true, frame=single, framesep=6pt, tabsize=2, fontfamily=courier, fontsize=\small}

\newminted{text}{xleftmargin=20pt, linenos=true, breaklines=true, frame=single, framesep=6pt, tabsize=2, fontfamily=courier, fontsize=\small}


% inline code
\newcommand{\code}[1]{\texttt{#1}}

% == Chapter titles
% Remove space before title
\titlespacing{\chapter}{0pt}{*-4}{*3}
% Remove "Chapter N" and use a sans-serif font
\titleformat{\chapter}{\normalfont\huge}{\thechapter.}{20pt}{\huge}
% Change chapter page style
\patchcmd{\chapter}{plain}{fancy}{}{}



% Metadata
\newcommand{\school}{Haute École d'ingénierie et d'architecture de Fribourg}
\newcommand{\oldreportname}{État de l’art à la mi-projet de semestre Docker and embedded systems - Ou comment ne pas cross compiler Docker sur ARM}

\title{Projet de semestre Docker and embedded systems}
\author{Gary \bsc{Marigliano}}
\newcommand{\version}{0.0.3}

% aliases
\newcommand{\odroid}{ODROID-XU3 Lite }

\begin{document}

\begin{titlepage}
\begin{center}

\includegraphics[width=0.6\textwidth]{img/docker_logo}\\[1cm]

\begin{figure}[htbp]
\begin{minipage}[c]{.45\linewidth}
\begin{flushleft}
\includegraphics[width=7cm]{img/mse_logo}
\end{flushleft}
\end{minipage}
\hfill
\begin{minipage}[c]{.45\linewidth}
\begin{flushright}
\includegraphics[height=2cm]{img/logo_hes-so}
\end{flushright}
\end{minipage}
\end{figure}

% Title
\rule{\linewidth}{0.5mm} \\[0.4cm]
{ \huge \bfseries \thetitle \\[0.4cm] }
\rule{\linewidth}{0.5mm} \\[1.5cm]

% Author and supervisor
\noindent
\begin{minipage}{0.4\textwidth}
  \begin{flushleft} \large
    \emph{Auteur :}\\
    \theauthor
  \end{flushleft}
\end{minipage}%
\begin{minipage}{0.4\textwidth}
  \begin{flushright} \large
    \emph{Encadrant :} \\
    Jean-Roland \bsc{Schuler}
  \end{flushright}
\end{minipage}

\vfill

\noindent
\begin{minipage}{0.4\textwidth}
  \begin{flushleft} \large
    \emph{Contact :}\\
    gary.marigliano@master.hes-so.ch
  \end{flushleft}
\end{minipage}%
\begin{minipage}{0.4\textwidth}
  \begin{flushright} \large
    \emph{Mandant :} \\
    \school
  \end{flushright}
\end{minipage}

\vfill

% Bottom of the page
{\large Version \version \\ \today}


\end{center}
\end{titlepage}

\pagestyle{historystyle}
\begin{versionhistory}
  \vhEntry{0.0.1}{02.05.16}{\theauthor}{Création du document}
  \vhEntry{0.0.2}{05.05.16}{\theauthor}{Ajout des chapitres Matériel utilisé, Présentation de Docker}
    \vhEntry{0.0.3}{11.05.16}{\theauthor}{Rédaction des sections Situation actuelle, Séparation des données Docker dans une partition chiffrée, Planning }
\end{versionhistory}


\chapter{Résumé du document}

TODO

\pagenumbering{gobble}
\tableofcontents
\pagenumbering{arabic}

\pagestyle{normal}

\chapter{Introduction}

\section{Contexte}\label{contexte}

Ce document est le rapport de fin de projet de semestre Docker and embedded systems. Un des buts de ce projet est de cross compiler Docker à partir de ses sources pour produire un binaire exécutable sur un \odroid (ARMv7). De plus, une partie concernant la sécurité de Docker est également traitée.

Lien: \url{https://github.com/krypty/docker_and_embedded_systems}

Ce projet de semestre s'inscrit dans une certaine continuité avec les projets de semestre et de bachelor de M. Loic Bassang \cite{bassang_bachelor}. Plusieurs pistes intéressantes avaient en effet été mentionnées dans ces projets-là notamment une partie concernant la sécurité et Docker. Ainsi, ce rapport fera parfois des parallèles avec ces documents.

Il est important de noter que la vitesse de développement de Docker est assez hallucinante. En effet, sur Github (\url{https://github.com/docker/docker}) les commits se succèdent à vitesse grand V. Entre chaque version de Docker, qui sortent environ tous les mois, il est courant d'avoir plus de 3000 commits qui ont été \emph{pushés}. Tout ceci pour dire qu'à la lecture de ce document, il est quasiment sûr que certaines pistes explorées soient définitivement obsolètes ou au contraire deviennent la voie à suivre du à une mise à jour quelconque.


\section{Objectifs}

De manière plus précise, ce projet vise à maitriser les parties suivantes:

\begin{enumerate}
  \item Construction d'un système Linux capable de faire tourner Docker et son \emph{daemon} en utilisant Buildroot. Pour générer le dit système, on dispose d'un \emph{repository} Gitlab hébergé à la \school

  \item Cross compilation de Docker et de son \emph{daemon}, capable de faire tourner des containers

  \item Comprendre, analyser et évaluer l'aspect sécurité de Docker dans le cadre d'une utilisation avec une carte embarquée
\end{enumerate}

Les deux premiers points ont été traités dans un précédent rapport appelé "\oldreportname" qu'il est recommandé de lire.

Ce document se concentre, dès lors, sur le dernier point ainsi que sur le déroulement global du projet.


\chapter{Présentation de Docker}

\textbf{Remarque : } Si le lecteur a déjà lu le rapport "\oldreportname", il ne lui est pas nécessaire de relire ce chapitre sachant qu'il s'agit du même contenu.

\input{../presentation-docker}

\chapter{Matériel utilisé et mise en place de la cible}

Ce chapitre présente le matériel utilisé dans le projet ainsi que son installation et sa configuration de base.

Afin de réaliser ce projet, une carte embarquée \odroid a été mise à disposition afin d'y faire tourner Docker.

\section{La carte \odroid}

Cette carte possède les caractéristiques suivantes \cite{hardkernel_odroid_xu3}:

\begin{itemize}
\item Samsung Exynos5422 Cortex™-A15 1.8Ghz quad core and Cortex™-A7 quad core CPUs
\item Mali-T628 MP6(OpenGL ES 3.0/2.0/1.1 and OpenCL 1.1 Full profile)
\item 2Gbyte LPDDR3 RAM at 933MHz (14.9GB/s memory bandwidth) PoP stacked
\item eMMC5.0 HS400 Flash Storage
\item USB 3.0 Host x 1, USB 3.0 OTG x 1, USB 2.0 Host x 4
\item HDMI 1.4a for display
\end{itemize}

\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.5]{img/ODROIDXU3Lite.jpg}
\caption{\odroid}
\end{figure}

Lien vers le constructeur : \url{http://www.hardkernel.com/main/products/prdt_info.php?g_code=G141351880955}.

\section{Installation du système}

Initialement, il était prévu de générer un système d'exploitation minimal qui aurait été capable de faire tourner Docker et des containers. Malheureusement, il n'a pas été possible de cross compiler Docker \textit{et son daemon} afin de lancer des containers sur ce système minimal. Plus d'informations sont disponibles dans le rapport "\oldreportname".

Ainsi, il a été décidé, de la même manière que pour le travail de bachelor précédent, d'utiliser une distribution GNU/Linux proposant Docker dans ses packages. Le choix s'est donc porté sur \textbf{Archlinux ARM} \footnote{Arch Linux ARM : \url{https://archlinuxarm.org/}}.

Sur la page wiki de la distribution (\url{https://archlinuxarm.org/platforms/armv7/samsung/odroid-xu3}), on peut suivre un guide de génération de la carte SD qui contient le système d'exploitation. Une copie de ce guide est disponible à l'appendice \ref{install_alarm_odroid}.


\section{Installation de Docker}
Une fois le système installé et démarré, il convient d'installer Docker depuis les dépôts de la distribution.

Ceci peut être accompli avec les commandes suivantes :

\begin{bashcode}
pacman -Syyu
reboot
pacman -S docker
systemctl enable docker
systemctl start docker
docker version
\end{bashcode}

Sortie:

\begin{bashcode}
Client:
 Version:      1.10.3
 API version:  1.22
 Go version:   go1.6
 Git commit:   20f81dd
 Built:        Sat Mar 12 12:49:56 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.10.3
 API version:  1.22
 Go version:   go1.6
 Git commit:   20f81dd
 Built:        Sat Mar 12 12:49:56 2016
 OS/Arch:      linux/arm
 \end{bashcode}


\chapter{Objectif 3 - Docker et la sécurité}

\section{Situation actuelle}
Pour cette partie du projet, l'objectif est le suivant : Analyser et évaluer l'aspect sécurité de Docker dans le cadre d'une utilisation avec une carte embarquée.

Pour rappel, on utilise la carte \odroid. Un des objectifs de ce projet était de générer un système GNU/Linux minimal contenant un binaire Docker cross-compilé. Malheureusement, cet objectif n'a pas abouti comme expliqué dans le rapport "\oldreportname".

Pour continuer sur la partie sécurité, il a été choisi d'utiliser une distribution GNU/Linux compatible avec la carte et qui propose dans ces dépôts un package Docker précompilé. Tout comme le travail précédent de M. Loïc Bassang, Arch Linux ARM a été sélectionné.

\section{Structure de la suite du document}

Pour ce projet, il a été décidé d'étudier la question de la sécurité avec Docker avec une approche en couches. A peu à la manière du modèle OSI\footnote{Modèle OSI: \url{https://fr.wikipedia.org/wiki/Mod\%C3\%A8le_OSI}} en réseau, chaque couche représente un ensemble de fonctionnalités qui, dans le cas de ce projet, doit faire l'objet d'une évaluation de la sécurité.

L'étude de la sécurité de Docker a donc été séparée avec les couches \textit{arbitraires} suivantes:

\begin{itemize}

\item Compilation et installation de Docker : en particulier les options  de compilation

\item \nameref{config_systeme_os_hote} : configuration du kernel, configuration des options de lancement de Docker, etc.

\item \nameref{creation_utilisation_images_docker} : Bonnes pratiques et contraintes liées au monde de l'embarqué

\item \nameref{utilisation_containers} : options de lancement

\end{itemize}

\textbf{Remarque : } Chacune de ces couches fait l'objet d'un chapitre dans ce rapport excepté le premier point : Compilation et installation de Docker. En effet, celui-ci n'est pas traité car, comme annoncé précédemment, la cross compilation de Docker sur un système ARM n'a pas aboutie. L'effort est alors concentré sur les autres points.


\chapter{Configuration du système d'exploitation hôte}\label{config_systeme_os_hote}
Dans ce chapitre, on présente diverses bonnes pratiques et configurations dans le but de sécuriser Docker et/ou le système l'hébergeant.

Parmi ces techniques, on peut citer :

\begin{itemize}
\item Création d'une partition chiffrée pour stocker les données de Docker (containers et images)
\item Modification des options de lancement du \textit{daemon} Docker
\end{itemize}


\section{Passage en revue du benchmark de sécurité : CIS Docker 1.11.0 Benchmark}
Il s'agit d'un document à l'intention d'administrateurs systèmes ou spécialistes de la sécurités qui souhaitent intégrer, développer ou sécuriser des solutions qui utilisent Docker.

Le but de ce document est de proposer un éventail de recommandations concernant la sécurité de Docker sur plusieurs points. Voici les points évalués :
\begin{enumerate}
\item \textit{Host Configuration} : Recommandations pour la configuration de la machine hôte
\item \textit{Docker daemon configuration} : Recommandations concernant le comportement du \textit{daemon} Docker
\item \textit{Docker daemon configuration files} : Recommandations concernant la permission des fichiers et dossiers de configuration du \textit{daemon} Docker
\item \textit{Container Images and Build File} : Recommandations concernant les images de base et les fichiers de build
\item \textit{Container runtime} : Recommandations sur les options de lancement des containers
\item \textit{Docker Security Operations} : Rappels des bonnes pratiques concernant la sécurité de Docker
\end{enumerate}

Lien : \url{https://benchmarks.cisecurity.org/tools2/docker/CIS_Docker_1.11.0_Benchmark_v1.0.0.pdf}

Dans cette partie du rapport, quelques points de ce benchmark seront analysés et appliqués à la cible dans des conditions les plus réelles possibles.

\subsection{Situation actuelle}
Avant de chercher à sécuriser la cible, il faut connaître son état de sécurisation actuel. Pour ce faire, il suffit de lancer le script du benchmark qui va exécuter toutes les recommandations proposées et indiquer quels points sont à corriger.

Avant de commencer, il faut lancer un container en arrière plan afin de pouvoir évaluer la partie \textit{5 - Container runtime} qui évalue les containers actuellement exécutés. Pour ce faire, on choisit de lancer en tâche de fond un serveur web sur la cible.

A faire sur la cible :
\begin{bashcode}
docker run --name=my_container -d -p 8080:80 hypriot/rpi-busybox-httpd
\end{bashcode}

Lancement du benchmark :
\begin{bashcode}
git clone https://github.com/docker/docker-bench-security.git
cd docker-bench-security/
sudo sh docker-bench-security.sh
\end{bashcode}

On obtient la sortie suivante :

\inputminted[xleftmargin=20pt, linenos=true, breaklines=true, frame=single, framesep=6pt, tabsize=2, fontfamily=courier, fontsize=\small]{text}{../../docker_security_benchmark/vanilla.log}


Comme on peut le voir, il y a plusieurs points qui sont en \textit{WARN}. Pour la suite du document, plusieurs de ces points vont être analysés et mitigés.


\subsection{1.1  - Create a separate partition for containers}
On recommande pour ce point de créer une partition séparée pour les containers. Ce point est traité à la section \ref{partition_chiffree}. Dans cette section, une étape supplémentaire est proposée; la partition est chiffrée.


\subsection{2.1  - Restrict network traffic between containers}
Par défaut, le trafic réseau est autorisé entre containers du même hôte. On devrait désactiver ce comportement par défaut et explicitement autoriser une communication entre containers grâce au "linking".

Pour remédier à ceci, il faut lancer le \textit{daemon} Docker avec cette option: \code{docker daemon --icc=false}

A faire sur la cible:

\begin{bashcode}
sudo vim /usr/lib/systemd/system/docker.service
\end{bashcode}

Ajouter l'option icc=false à l'instruction ExecStart. Le résultat devrait ressembler à ceci:

\begin{bashcode}
ExecStart=/usr/bin/docker daemon -H fd:// --icc=false
\end{bashcode}

Redémarrage du daemon:

\begin{bashcode}
sudo systemctl daemon-reload # recharge la configuration des services
sudo systemctl restart docker # relance le service docker
\end{bashcode}

Résultat du benchmark après cette modification: \code{[PASS] 2.1 - Restrict network traffic between containers}.

\subsection{2.5 - Do not use the aufs storage driver}
Pour stocker les images et les différentes couches qui les composent, Docker utilise un driver de stockage\cite{understanding_image_container_driver_storage}, \cite{docker_select_a_driver}, \cite{jpetazzoni_device_driver}. Un driver de stockage (\textit{driver storage}) est l'implémentation d'une abstraction de services liés à la gestion des couches des images et de la couche inscriptible (\textit{writable}) des containers. L'utilisation d'un driver ou d'un autre est transparent pour l'utilisateur. Cependant, une certaine implémentation, aufs, est considérée peu stable et peut causer des crashes au niveau du kernel, voir \cite{cis_benchmark} page 45. Ce driver est donc à remplacer par un autre driver de stockage comme devicemapper par exemple.

Inconvénient: aufs est le seul driver de stockage qui permet aux containers de partager la mémoire des librairies partagées. Cela peut être utile si la cible fait tourner des milliers de containers utilisant les mêmes programmes ou librairies \cite{cis_benchmark}.

Dans le cadre d'une carte embarquée, on ne va pas faire tourner des milliers de containers en même temps et par conséquent changer de driver storage n'est pas un problème.

Par défaut Docker utilise devicemapper mais suivant la distribution ou la plateforme utilisée, un autre storage driver est utilisé. Dans le cas présent, aufs est malheureusement utilisé.

Vérification que device-mapper est présent sur le système:

\begin{bashcode}
[alarm@alarm docker-bench-security]# pacman -Qi device-mapper
Name            : device-mapper
Version         : 2.02.149-1
Description     : Device mapper userspace library and tools
Architecture    : armv7h
URL             : http://sourceware.org/dm/
Licenses        : GPL2  LGPL2.1
Groups          : base
Provides        : None
Depends On      : glibc  systemd
Optional Deps   : None
Required By     : cryptsetup  docker  lvm2
Optional For    : None
Conflicts With  : None
Replaces        : None
Installed Size  : 871.00 KiB
Packager        : Arch Linux ARM Build System <builder+xu2@archlinuxarm.org>
Build Date      : Sun Apr 17 12:52:54 2016
Install Date    : Mon Apr 18 14:12:44 2016
Install Reason  : Explicitly installed
Install Script  : No
Validated By    : SHA-256 Sum
\end{bashcode}

Comme avant, on change les paramètres de lancement du \textit{daemon} Docker:

\begin{bashcode}
sudo vim /usr/lib/systemd/system/docker.service
\end{bashcode}

Ajouter l'option \code{--storage-driver=devicemapper} à l'instruction ExecStart. Le résultat devrait ressembler à ceci:

\begin{bashcode}
ExecStart=/usr/bin/docker daemon -H fd:// --icc=false --storage-driver=devicemapper
\end{bashcode}

\begin{bashcode}
sudo systemctl daemon-reload # recharge la configuration des services
sudo systemctl restart docker # relance le service docker
\end{bashcode}


\subsection{2.8 - Enable user namespace support}
Les namespaces permettent d'isoler certaines fonctionnalités d'un système d'exploitation utilisant Linux. Comme chroot permet aux processus de voir comme racine un dossier isolé du système et non pas la "vraie" racine, les namespaces isolent certains aspects du système comme les processus, les interfaces réseaux, les points de montage, etc.

Jusqu'à très récemment (docker < 1.10.0), Docker supportait les namespaces suivants:
\begin{itemize}
\item PID namespace, chaque conteneur a ses propres id de processus
\item UTS namespace, pour avoir son propre hostname
\item IPC namespace, qui permet d'isoler les Communications Inter-Processus
\item Network namespace, chaque conteneur peux avoir sa propre interface réseau, son ip, ses règles de filtrage
\end{itemize}

Pour plus de détails, voir section \ref{pres-docker-isolation}.

Il y a peu de temps, Docker ajouté le support d'un nouveau namespace\cite{docker_1_10_user_namespace}: user namespace. Celui-ci permet à un processus d'avoir les droits root au sein d'un namespace mais pas en dehors. Avant, Docker lançait les containers en root ce qui pouvait poser des problèmes de sécurité si un processus dans le container venait à en sortir; il se retrouverait root sur le système hôte. Avec la prise en charge de ce namespace, un container Docker a l'impression d'être root alors qu'il n'est, en réalité, qu'un utilisateur normal sur le système hôte.

Pour mettre en place ce mécanisme, il faut réaliser les opérations suivantes :

\begin{bashcode}
touch /etc/subuid /etc/subgid
\end{bashcode}

Et ajouter l'option \code{--userns-remap=default} au démarrage du \textit{daemon} Docker.

Malheureusement, il a été impossible de démarrer le \textit{daemon} avec cette option que ce soit sur la cible (Archlinux, kernel 3.10.96), sur un portable Archlinux (kernel 4.5.4) ou sur un autre portable Xubuntu 16.04 (kernel 4.4.0). Le \textit{daemon} refusait de démarrer ou se bloquait. Il semblerait que cela ne soit pas un cas isolé. En effet plusieurs issues (\#20751, \#21130\footnote{Docker issues : \url{https://github.com/docker/docker/issues}}) ont été ouvertes sur le \textit{repository} Github de Docker.


\subsection{2.11 - Use authorization plugin}
Le modèle de permission Docker par défaut est tout ou rien. Tout utilisateur qui a accès au \textit{daemon} Docker peut effectuer n'importe quelles opérations sur tous les containers. Dans le cas où l'on a besoin d'un contrôle plus fin, il est possible de créer des plugins d'autorisation (\textit{authorization plugins}) et les ajouter à la configuration du \textit{daemon} Docker. Il est, par exemple, possible de définir que l'utilisateur Bob ne puisse pas arrêter les containers mais uniquement les lister.

Un plugin d'autorisation approuve ou refuse les requêtes du client (un utilisateur)  vers le \textit{daemon} en se basant sur le contexte actuel d'authentification et le contexte de commande. Le contexte d'authentification contient toutes les détails de l'utilisateur et de la méthode d'authentification et le contexte de commande contient toutes les données utiles à la requête de l'utilisateur.

\textbf{Remarque : } La communication entre le \textit{daemon} et le client\cite{docker_doc_daemon} se fait à travers un socket Unix (\code{/var/run/docker.sock}) mais peut aussi se faire via un socket TCP (\code{tcp://0.0.0.0:2375}) pour accéder au \textit{daemon} de manière distante. Grâce à ce mécanisme, Docker propose \textit{Docker Remote API}\cite{docker_doc_remote_api} une API \textit{REST-like} qui permet d'accéder à la liste des containers, des images, de créer des containers, etc.

Pour créer un plugin d'autorisation, il faut respecter le contrat décrit par la \textit{Docker Plugin API}. De manière similaire à la \textit{Docker Remote API}, cette API définit un cadre afin d'étendre les possibilités de Docker comme par exemple autoriser ou refuser l'accès à certaines fonctionnalités de Docker pour un utilisateur ou un groupe donné.


Maintenant les notions de communication client \textit{daemon} et API REST éclaircies, on peut enfin voir l'architecture de base des plugins d'autorisation.

\begin{figure}[H]
    \subfloat[Cas où la requête est autorisée]{%
      \includegraphics[width=0.45\textwidth]{img/auth_plugins/authz_allow.png}
    }
    \hfill
    \subfloat[Cas où la requête est refusée]{%
      \includegraphics[width=0.45\textwidth]{img/auth_plugins/authz_deny.png}
    }

    \caption[]{Scénarios d'autorisation Docker\protect{\footnotemark}}
\end{figure}

\footnotetext{Source des images : \url{https://docs.docker.com/engine/extend/plugins_authorization/}}

Comme on peut le voir sur les figures ci-dessus, les requêtes sont des requêtes HTTP JSON comme on peut le trouver fréquemment dans avec les API REST.

Il est possible d'utiliser plusieurs plugins en même temps. Dans ce cas, pour qu'une requête soit acceptée, il faut qu'elle puisse traverser tous les plugins (donc être approuvée par tous les plugins). Si un seul plugin refuse la requête alors elle est refusée.

La création et mise en place de plugin n'est pas présenté dans ce rapport. Néanmoins, voici un exemple de plugin : \url{https://github.com/twistlock/authz}.

\textbf{Analyse : } Dans le cas d'une utilisation embarquée, il n'est pas indispensable d'avoir recours à un contrôle plus fin de l'utilisation de Docker car :
\begin{itemize}
\item la cible est souvent mono-utilisateur
\item les containers appartiennent tous au même utilisateur. Dans le cas d'une plateforme offrant un service de type CaaS (Containers as a Service), on peut comprendre que chaque utilisateur n'ait accès qu'aux containers qu'il lance.
\end{itemize}
Par conséquent, on décide de ne pas mettre en place ce mécanisme. On rappelle que ce benchmark a surtout pour but de montrer un ensemble de bonnes pratiques et de rendre attentif à certains aspects de la sécurité avec Docker. Il n'est néanmoins pas toujours indispensable d'appliquer toutes les mesures de sécurités si on en exprime pas le besoin.


\subsection{2.12 - Configure centralized and remote logging}
Docker supporte plusieurs \textit{log drivers} (manière de journaliser). Par défaut, les logs des containers sont produits dans des fichiers JSON sur la machine hôte. Mais il est recommandé de centraliser les logs sur une machine distante pour voir et traiter les logs globalement.

Le benchmark CIS recommande d'externaliser les logs en optant pour le log driver \textit{syslog}. \textit{Syslog}\cite{developpez_syslog}\cite{wiki_syslog} est un protocole définissant un service de journaux d'évènements d'un système informatique. Son but est de transporter par réseau les messages de journalisation générés par une application (dans ce cas Docker) vers un serveur hébergeant un serveur \textit{Syslog}. Le but étant de regrouper tous les journaux au même endroit.

Pour la suite, on va mettre en place un petit exemple de démonstration qui n'a absolument pas la prétention d'être exhaustif ni sécurisé. Cet exemple a uniquement pour but de montrer un cas simple de \textit{remote logging}.

Pour cet exemple, il y a à disposition un ordinateur portable qui fait office de serveur \textit{Syslog} et la cible Odroid qui va lancer un container dont les logs sont envoyés à l'ordinateur portable. On peut voir cette configuration ci-dessous.

\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{img/docker_syslog.png}
\caption{Structure de démonstration Syslog}
\end{figure}

Le container (ici Ubuntu) va être lancé en indiquant que les logs doivent être envoyés au PC portable disposant d'un serveur syslog dans un container appelé rsyslog.

Pour le serveur \textit{Syslog}, un container Docker prêt à l'emploi va être utilisé. Ce container utilise une image Rsyslog dont la source se trouve ici: \url{https://hub.docker.com/r/panoptix/rsyslog/}.

Lancement du container Rsyslog sur le portable et affichage des logs distants :
\begin{bashcode}
# démarrage du container
docker run --name rsyslog -t -d -p 514:514/udp -p 514:514 panoptix/rsyslog

# affichage des logs en temps réel
docker exec -it rsyslog bash
tail -f /var/log/syslog
\end{bashcode}

Lancement du container Ubuntu (producteur de logs) sur la cible :
\begin{bashcode}
docker run -d --log-driver=syslog --log-opt syslog-address=tcp://192.168.2.26 --log-opt tag="remote" armhf/ubuntu echo "hello from Odroid"
\end{bashcode}

Ce container va lancer la commande \code{echo} et se stopper immédiatement après. Évidemment dans un cas réel, le container effectuera des opérations plus longues et produirait un plus grande quantité de logs mais ici le but est de voir le principe général.

Sur l'ordinateur portable, on peut observer l'affichage suivant :
\begin{bashcode}
May 22 18:23:42 fc6dca22947a rsyslogd: [origin software="rsyslogd" swVersion="8.11.0" x-pid="1" x-info="http://www.rsyslog.com"] start
May 22 18:38:09 192.168.2.16 docker/remote[284]: hello from Odroid
\end{bashcode}

Comme on peut le voir, on est capable de récupérer les logs de la cible sur l'ordinateur portable.

\textbf{Remarque : } Pour cet exemple, les options de logging ont été précisés au niveau du lancement du container (\code{--log-driver=XXX --log-opt syslog-address=tcp://aaa.bbb.ccc.ddd --log-opt YYY}). Idéalement, il faudrait définir par défaut toutes ces options au démarrage du \textit{daemon}. Pour ce faire, il suffit de modifier la configuration de lancement du \textit{daemon} comme il a été montré aux sections précédentes. Par exemple, on pourrait configurer le \textit{daemon} ainsi :

\begin{bashcode}
ExecStart=/usr/bin/docker daemon -H fd:// --icc=false --storage-driver=devicemapper --log-driver=XXX --log-opt syslog-address=tcp://aaa.bbb.ccc.ddd --log-opt YYY
\end{bashcode}

\textbf{Analyse : } On l'a vu les containers produisent des logs qu'il est recommandé de centraliser sur une machine distante. Pour ce faire, Docker propose plusieurs \textit{log drivers} qui permettent ce besoin. Dans cet exemple, \textit{Syslog} a été utilisé mais il existe d'autres \textit{log drivers}\footnote{Docker log drivers : \url{https://docs.docker.com/engine/admin/logging/overview/}}.

L'exemple présenté est sommaire mais il montre le principe général. Dans un cas plus pratique, par exemple un ensemble de cibles qui transmettent la température ambiante à un serveur (ou autre application IoT), on configurerait les cibles pour émettre leurs logs sur un serveur distant. Ce serveur disposerait ensuite d'une interface web affichant l'ensemble des logs des cibles et il serait ainsi possible de suivre le fonctionnement de toutes les cibles. De plus, dans un cas pratique, il faudrait aussi veiller à regarder le contenu de l'image rsyslog téléchargée et vérifier qu'elle fasse bien uniquement ce qu'on lui demande et rien de plus ou alors créer une image rsyslog de toutes pièces.


\subsection{2.13 - Disable operations on legacy registry (v1)}
Un \textit{registry} est un service responsable de l'hébergement et de la distribution d'images Docker. C'est une sorte d'App Store pour image Docker. Le \textit{registry} par défaut est Docker Hub\footnote{Docker Hub : \url{http://hub.docker.com/}}. Il est également possible d'utiliser son propre \textit{registry}. Dans tous les cas, il est recommandé de ne plus utiliser la version 1 de l'API de communication avec les \textit{registries} car la version 2 permet notamment le transfert sécurisé de données en utilisant TLS\cite{blog_docker_registry_v2}.

Pour forcer Docker a n'utiliser que des \textit{registries} v2, il suffit d'ajouter l'option \code{--disable-legacy-registry} au démarrage du \textit{daemon} Docker.

A faire sur la cible:

\begin{bashcode}
sudo vim /usr/lib/systemd/system/docker.service
\end{bashcode}

Ajouter l'option icc=false à l'instruction ExecStart. Le résultat devrait ressembler à ceci:

\begin{bashcode}
ExecStart=/usr/bin/docker daemon -H fd:// --icc=false --storage-driver=devicemapper --disable-legacy-registry
\end{bashcode}

Redémarrage du daemon:

\begin{bashcode}
sudo systemctl daemon-reload # recharge la configuration des services
sudo systemctl restart docker # relance le service docker
\end{bashcode}

Résultat du benchmark après cette modification: \code{[PASS] 2.13 - Disable operations on legacy registry (v1)}.


\subsection{4.1  - Create a user for the container}
Par défaut, lorsqu'on lance un container, l'utilisateur à l'intérieur de ce container est root. Pour des raisons évidentes de sécurité, root n'est pas toujours l'utilisateur le plus adapté quand on lance un container. De plus, si par une quelconque raison, on arrive à sortir du container, on se retrouve root sur la machine hôte !

Pour mitiger ces effets, il est possible de :
\begin{itemize}
\item Créer un utilisateur avec des droits limités dans l'image du container (\code{USER toto} dans le Dockerfile)
\item Spécifier l'utilisateur à utiliser lors du lancement du container (\code{docker run --user toto})
\item Faire croire au container qu'il est root alors qu'en réalité il s'agit d'un utilisateur à droits limités (user namespace)
\end{itemize}

La suite a pour but de montrer les différentes techniques pour changer l'utilisateur au sein du container.

\subsubsection{État initial}
On utilise l'image Alpine sans modifications et on observe les résultats suivants :

\begin{textcode}
docker run -it alpine /bin/sh
/ # whoami
root
/ # touch /root.txt
/ # ls /root.txt
/root.txt
/ # ls -l /root.txt
-rw-r--r--    1 root     root             0 May 23 13:41 /root.txt
\end{textcode}

On voit que par défaut l'utilisateur dans le container est root. Cet utilisateur peut donc écrire un fichier à la racine.

\subsubsection{Dans le Dockerfile}
Pour l'exemple qui suit, on va créer une image qui utilise Alpine Linux comme base. Cette image est modifiée pour qu'elle se lance par défaut avec un utilisateur toto qui a des droits limités.

\begin{bashcode}
mkdir alpine-user
vim Dockerfile
\end{bashcode}

Dans le Dockerfile, on écrit :
\begin{bashcode}
FROM alpine

# tâches nécessitant un accès root
# par exemple, installer des packages
RUN apk update && apk add vim

# fin des tâches demandant un accès root
# passage à un user à droits limités
RUN adduser -h /home/toto -s /bin/sh -D toto
USER toto

CMD ["/bin/sh"]
\end{bashcode}

On utilise donc l'image de base d'Alpine sur laquelle on effectue des tâches administratives nécessitant root. Une fois ces tâches effectuées, il n'est plus nécessaire d'être root. On crée alors un utilisateur à droit limité appelé toto. C'est cet utilisateur qui sera utilisé par défaut au lancement d'un container utilisant cette image.

\begin{textcode}
docker run -it alpine-user
/ whoami
toto
/ touch /toto.txt
touch: /toto.txt: Permission denied
\end{textcode}

Ici, on voit que l'utilisateur en cours est toto et qu'il n'a pas les droits root.

\subsubsection{Au lancement du container}
Il est également possible de spécifier l'utilisateur à utiliser au lancement du container grâce à l'option \code{--user}.

Les cas suivants sont testés :
\begin{itemize}
\item root : on peut spécifier root si l'image a défini un autre utilisateur par défaut. Utilisation déconseillée.
\item nobody : l'utilisateur nobody est un utilisateur aux droits très limités et la plupart des distributions l'intègre de base donc pas besoin le créer expressément.
\item gary : cas où l'utilisateur existe sur l'hôte mais pas dans le container
\item toto : cas où l'utilisateur n'existe pas sur l'hôte mais dans le container
\end{itemize}

\textbf{Utilisateur root} :
\begin{textcode}
> docker run --user root -it alpine-user
/ # whoami
root
/ # touch /root.txt
/ # ls -al /root.txt
-rw-r--r--    1 root     root             0 May 23 19:35 /root.txt
\end{textcode}

Le container est lancé en root. On peut écrire à la racine sans souci.

\textbf{Utilisateur root} :
\begin{textcode}
> \$ docker run --user nobody -it alpine-user
~ \$ whoami
nobody
~ \$ touch /nobody.txt
touch: /nobody.txt: Permission denied

\end{textcode}

Le container est lancé avec l'utilisateur nobody (présent sur l'OS hôte et surtout dans le container). L'écriture sur \code{/} est refusée.


\textbf{Utilisateur gary} :
\begin{textcode}
> docker run --user gary -it alpine-user
docker: Error response from daemon: linux spec user: Unable to find user gary.
\end{textcode}

Lancer un container avec un utilisateur qui n'existe pas dans le container n'est pas possible.

\textbf{Utilisateur toto} :
\begin{textcode}
> \$ docker run --user toto -it alpine-user
/ \$ whoami
toto
/ \$ touch /toto.txt
touch: /toto.txt: Permission denied
\end{textcode}

Le container est lancé avec l'utilisateur toto (absent sur l'OS hôte et mais présent dans le container). L'écriture sur \code{/} est refusée.

\textbf{Analyse :} on remarque que par défaut, les containers sont lancés en root. Si le container n'a pas besoin d'avoir des accès root, il est fortement recommandé de construire une image mettant en place un utilisateur à droits limités. Dans le cas où l'on utilise une image écrite par quelqu'un d'autre, on peut essayer de lancer avec l'utilisateur nobody si on estime qu'elle n'a pas besoin des droits root pour fonctionner. Évidemment, cela ne fonctionnera pas si l'image a réellement besoin des droits root comme par exemple pour installer des packages.

Le dernier cas concerne l'utilisation du user namespace. Ici c'est différent, on mappe un utilisateur standard de la machine hôte à l'utilisateur root du container. Ainsi, on peut effectuer des tâches nécessitant les droits root dans le container. Cependant, si le processus au sein du container vient à s'en échapper, il n'est pas root mais l'utilisateur mappé aux droits limités.

\subsubsection{En utilisant le user namespace}
TODO voir chapitre dédié

\begin{bashcode}
gary@gary-portable ~/alpine-hello-world
> \$ docker run -it alpine /bin/sh
/ # whoami
root
/ # exit

gary@gary-portable ~/alpine-hello-world
> \$ docker run --user nobody -it alpine /bin/sh
~ \$ whoami
nobody
~ \$ whoami
~ \$ exit

gary@gary-portable ~/alpine-hello-world                                                                    [11:21:48]
> \$ docker run --user gary -it alpine /bin/sh
docker: Error response from daemon: linux spec user: Unable to find user gary.
\end{bashcode}


\subsection{4.5  - Enable Content trust for Docker}
TODO

\subsection{5.3  - Restrict Linux Kernel Capabilities within containers}
TODO

\subsection{5.4  - Do not use privileged containers}
TODO explain only

\subsection{5.6  - Do not run ssh within containers}
TODO explain only

\subsection{5.10 - Limit memory usage for container}
TODO

\subsection{5.11 - Set container CPU priority appropriately}
TODO

\subsection{5.12 - Mount container's root filesystem as read only}
TODO explain only


\subsection{Situation finale}
TODO


\section{Séparation des données Docker dans une partition chiffrée}\label{partition_chiffree}
Dans cette section, une partition chiffrée sera créée sur la cible afin d'isoler les données (images et containers principalement) de Docker du reste du système. La partition sera chiffrée afin d'accroître la sécurité des données.

Les étapes suivantes seront réalisées :
\begin{enumerate}
\item Redimensionnement de la partition principale
\item Création d'une partition chiffrée
\item Montage manuel de la partition chiffrée
\item Montage au boot de la partition chiffrée
\item Preuve de bon fonctionnement du montage automatique
\item Binding des données de Docker sur la partition chiffrée
\item Analyse de la solution proposée
\end{enumerate}

\subsection{Redimensionnement de la partition principale}
Actuellement, il n'y a qu'une partition sur la cible; la partition principale. Il faut réduire la partition principale et créer une partition dans le nouvel espace libre. Pour ce faire, l'outil GParted\footnote{GParted : \url{http://gparted.org/}} a été utilisé car il permet de voir visuellement ce qui est réalisé.



\begin{figure}[H]
    \subfloat[Situation initiale - Une seule partition]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gparted1.png}
    }
    \hfill
    \subfloat[Redimensionnement de la partition principale]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gparted2.png}
    }

    \subfloat[Création de la partition pour les données Docker]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gparted3.png}
    }
    \hfill
    \subfloat[Confirmation]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gparted4.png}
    }

     \subfloat[Partitionnement en cours...]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gparted5.png}
    }
    \hfill
    \subfloat[Situation finale - Deux partitions, la principale et celle pour Docker]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gparted6.png}
    }
    \caption{Redimensionnement de la partition principale}
\end{figure}

\subsection{Création d'une partition chiffrée}

Maintenant que la carte SD correctement partitionnée, il faut créer la partition chiffrée avec LUKS. Pour ce faire, Gnome Disks Utility est utilisé\footnote{Gnome Disk Utility : \url{https://doc.ubuntu-fr.org/gnome-disk-utility}}.

\begin{figure}[H]
    \subfloat[Sélection de la partition à chiffrer. Cliquer sur la roue crantée et sélectionner "Format Partition...".]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gnome-disks1.png}
    }
    \hfill
    \subfloat[Sélectionner "Encrypted, compatible with Linux systems (LUKS + ext4)" et saisir une passphrase (mot de passe)]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gnome-disks2.png}
    }

    \subfloat[La partition chiffrée est créée]{%
      \includegraphics[width=0.45\textwidth]{img/luks/gnome-disks3.png}
    }
    \caption{Création de la partition chiffrée avec Gnome Disk Utility}
\end{figure}


\subsection{Montage manuel de la partition chiffrée}
Maintenant que la partition chiffrée a été créée, on peut replacer la carte SD dans la cible et la démarrer.

Pour monter manuellement la partition, il faut réaliser les commandes suivantes :
\begin{bashcode}
sudo mkdir /mnt/docker-data
sudo cryptsetup luksOpen /dev/mmcblk0p2 docker-data
sudo mount /dev/mapper/docker-data /mnt/docker-data/
\end{bashcode}

\code{/dev/mmcblk0p2} représente la partition chiffrée de la carte SD.

\subsection{Montage au boot de la partition chiffrée}
Monter manuellement la partition n'est pas une solution possible si l'on souhaite y mettre les données de Docker dessus. En effet, pour que Docker stocke ces données (rappel: les images et les containers) dans la partition chiffrée, il faut monter cette partition au démarrage de la cible et créer un \textit{bind mount} sur \code{/var/lib/docker}.


Avant d'effectuer le \textit{bind mount}, il faut faire en sorte de monter la partition chiffrée au boot.


Pour monter la partition chiffrée au démarrage du système, il faut ouvrir le fichier \code{/etc/crypttab} sur la cible, et ajouter la ligne suivante :
\begin{bashcode}
docker-data /dev/mmcblk0p2  none luks
\end{bashcode}

De manière similaire, il faut ajouter cette ligne dans le fichier \code{/etc/fstab} :
\begin{bashcode}
/dev/mapper/docker-data /mnt/docker-data ext4 rw 0 0
\end{bashcode}


\subsection{Preuve de bon fonctionnement du montage automatique}
Pour vérifier que tout ceci fonctionne bien, il suffit de redémarrer la cible et on devrait observer les lignes suivantes au boot :

\begin{bashcode}
[  OK  ] Found device /dev/mmcblk0p2.
         Starting Cryptography Setup for docker-data...
Please enter passphrase for disk docker-data on /mnt/docker-data! ******
[***   ] (1 of 2) A start job is running for...for docker-data (13s / no limit)[   22.871246] [c5] NET: Registered pr8
[**    ] (1 of 2) A start job is running for...for docker-data (13s / no limit)[   23.925487] [c6] bio: create slab <1
[  OK  ] Found device /dev/mapper/docker-data.
[  OK  ] Started Cryptography Setup for docker-data.
[  OK  ] Reached target Encrypted Volumes.
         Mounting /mnt/docker-data...
[   24.117386] [c5] EXT4-fs (dm-0): mounted filesystem with ordered data mode. Opts: (null)
[  OK  ] Mounted /mnt/docker-data.
\end{bashcode}

Le système va se bloquer pour que la saisie de la passphrase soit effectuée :
\begin{bashcode}
Please enter passphrase for disk docker-data on /mnt/docker-data! ******
\end{bashcode}

Une fois connecté, il est tout à fait possible de d'écrire des données sur la partition chiffrée :
\begin{bashcode}
echo "LUKS je suis ton père !" > /mnt/docker-data/starwars.txt
\end{bashcode}


\subsection{Binding des données de Docker sur la partition chiffrée}
Maintenant, on veut faire en sorte que les données de Docker soient dans cette partition chiffrée. Pour ce faire, on va effectuer un \textit{bind mount} entre un dossier dans la partition chiffrée et le dossier de Docker.

Un \textit{bind mount} n'est rien d'autre qu'un montage de dossier dans un autre dossier. On va donc monter \code{/mnt/docker-data/docker} dans \code{/var/lib/docker}. De cette manière, aucune configuration supplémentaire de Docker n'est nécessaire et ceci est donc complètement transparent pour lui. Cette opération est persistante après un redémarrage. Les \textit{bind mount} sont également utilisés comme redirection pour ne pas avoir de points de montage introuvables s'ils ont été déplacés.

\textbf{Attention : } Les opérations suivantes impliquent la perte de toutes les images et containers précédemment créés.

Création du dossier \code{docker} sur la partition chiffrée, à faire sur la cible :
\begin{bashcode}
sudo systemctl stop docker # on stoppe le service Docker avant tout
cd /mnt/docker-data
mkdir -p var/lib/docker
sudo rm -rf /var/lib/docker/ # supprime toutes les données de Docker !!!
sudo mkdir /var/lib/docker
\end{bashcode}

Sur la cible, on fait ensuite un \textit{bind mount} entre la partition chiffrée et le dossier Docker de base

\begin{bashcode}
sudo vim /etc/fstab

# dans ce fichier, on ajoute la ligne suivante
/mnt/docker-data/var/lib/docker /var/lib/docker none bind 0 0
\end{bashcode}

A la suite de ces modifications, le fichier /etc/fstab ressemble à ceci:
\begin{bashcode}
#
# /etc/fstab: static file system information
#
# <file system> <dir>   <type>  <options>       <dump>  <pass>
/dev/mapper/docker-data /mnt/docker-data ext4 rw 0 0
/mnt/docker-data/var/lib/docker /var/lib/docker none bind 0 0
\end{bashcode}


Désormais les données de Docker sont stockées sur une partition séparée et chiffrée. Pour prouver que c'est bien le cas, il suffit de relancer le benchmark de sécurité:

\begin{bashcode}
cd /home/alarm/docker/docker-bench-security
sudo bash docker-bench-security.sh

# la sortie indique:
[PASS] 1.1  - Create a separate partition for containers
\end{bashcode}


\subsection{Analyse de la solution proposée}
Stocker les données de Docker dans une partition chiffrée est une bonne initiative mais il faut garder à l'esprit les implications suivantes :
\begin{itemize}

\item La partition chiffrée est montée au boot. Ceci implique quand cas de reboot de la machine, il faut avoir un accès physique à celle-ci car le service ssh n'est pas encore lancé à ce moment là. En cas de dépannage à distance, il n'est pas donc possible de reboot la cible.
\item Les performances quand on utilise Docker devraient être diminuées dû au chiffrement
\item L'utilisation d'une partition séparée permet de réinstaller le système sans perdre les données liées à Docker et ses containers.
\item Le chiffrement des containers Docker apporte une plus value en terme de sécurité
\end{itemize}

\section{Conclusion sur la configuration du système d'exploitation hôte}
TODO dire ce qui s'est passé et ce qui serait bien de faire en plus.


\chapter{Création et utilisation des images Docker}\label{creation_utilisation_images_docker}
TODO : ce chapitre montre comment et pourquoi créer et utiliser des images Docker qui soient sécurisées et adaptées au monde de l'embarqué (taille principalement). Utilisation des hash cryptographiques pour l'OS utilisé et les versions des logiciels installés.
Montrer un cas pratique avec une image commune basée sur alpine linux dire ce que ca apporte de travailler ainsi et pourquoi il faut le faire.


\chapter{Utilisation des containers}\label{utilisation_containers}
TODO : parler de la philosophie des containers légers et éphémères, comment les exécuter de manière sûre et sécurisée, comment limiter le pouvoir des containers (conso ram, ddos, communication avec le monde extérieur ou entre containers, ...)

\begin{landscape}
\chapter{Déroulement du projet}


\section{Planning initial}
\begin{figure}[ht]
\centering
\includegraphics[height=4.7cm]{img/initial_planning.png}
\caption{Planning initial - 04.03.2016}
\end{figure}


\section{Planning final}
\begin{figure}[ht]
\centering
\includegraphics[draft,height=4.7cm]{img/initial_planning.png}
\caption{Planning final - TODO date}
\end{figure}

\end{landscape}
\chapter{Proposition d'améliorations vis à vis du travail précédent}
TODO: Pas prioritaire, a voir si on a le temps ! passer en revue et critique positivement le travail de Bachelor précédent. Dire que ce n'est pas une critique négative mais apporter un avis supplémentaire et plus récent (Docker évoluant beaucoup)


\chapter{Conclusion}
TODO... ce qu'on voulait faire, ce qui a été fait, ce qu'il reste à faire/pourrait faire


% == Bibliography
\nocite{*} % cite all
\bibliographystyle{plain}
\bibliography{bibliography}

\begin{appendices}
\chapter{Installation de Archlinux ARM sur \odroid}\label{install_alarm_odroid}

\textbf{Remarque : }Ce guide requiert l'utilisation d'un ordinateur sous GNU/Linux.

Source : \url{https://archlinuxarm.org/platforms/armv7/samsung/odroid-xu3}

\input{appendices/archlinux_arm_odroid_xu3_install}

\end{appendices}

\end{document}
